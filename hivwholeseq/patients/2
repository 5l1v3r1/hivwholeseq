# vim: fdm=marker
'''
author:     Fabio Zanini
date:       02/07/14
content:    Explore sites that are very conserved within our patient set, across
            the whole infection, compared to their behaviour within the subtype.
'''
# Modules
import os
import argparse
from collections import defaultdict
from operator import itemgetter
import numpy as np
from matplotlib import cm
import matplotlib.pyplot as plt
from Bio import SeqIO, AlignIO

from hivwholeseq.miseq import alpha
from hivwholeseq.patients.filenames import root_patient_folder
from hivwholeseq.filenames import reference_folder
from hivwholeseq.patients.patients import load_patients, Patient

# Globals
tree_ali_foldername = reference_folder+'alignments_trees/typeM/'
colors = {'p17': 'r',
          'p24': 'g',
          'PR': 'r',
          'RT': 'g',
          'p15': 'purple',
          'IN': 'orange',
          'gp41': 'r'}



# Functions
def get_subtype_B_obs(protname, seqm, VERBOSE=0):
    '''Get the observables from subtype B alignments'''
    aliB_fn = tree_ali_foldername+protname+'.B.nuc.aligned.fasta'
    aliB = AlignIO.read(aliB_fn, 'fasta')
    aliBm = np.array(aliB, 'S1')
    # Get allele freqs ignoring ambiguous: N, Y, R, etc. and renormalizing
    nuBm = np.array([(aliBm == a).mean(axis=0) for a in alpha[:5]])
    nuBm /= nuBm.sum(axis=0)
    seqBm = alpha[nuBm.argmax(axis=0)]
    seqBm[seqBm == '-'] = 'X'
    S = np.zeros(len(seqBm))
    for nuB in nuBm:
        S -= (nuB + 1e-8) * np.log2(nuB + 1e-8)

    # Align alignments -- pairwise ;-)
    band = 50

    # Start
    seed = seqBm[:10]
    n_match = [(seqm[i: i + len(seed)] == seed).sum() for i in xrange(len(seqm) - len(seed))]
    pos = np.argmax(n_match)
    if n_match[pos] < 0.65 * len(seed):
        raise ValueError('ERROR: start not found')
    start = pos

    # End
    if protname == 'gp41':
        threshold = 0.6
    else:
        threshold = 0.7
    seed = seqBm[-10:]
    lp = len(seqBm)
    search_start = start + lp - band
    search_end = min(search_start + 2 * band, len(seqm) - len(seed))
    n_match = [(seqm[i: i + len(seed)] == seed).sum() for i in xrange(search_start, search_end)]
    pos = np.argmax(n_match)
    if n_match[pos] < threshold * len(seed):
        # Integrase ends slightly after the end of F3a, so we try and do the opposite, we trim IN
        if protname == 'IN':
            end = len(seqm)
            seed = seqm[-15:]
            search_start = len(seqBm) - 100
            search_end = len(seqBm) - len(seed)
            n_match = [(seqBm[i: i + len(seed)] == seed).sum() for i in xrange(search_start, search_end)]
            pos = np.argmax(n_match)
            if n_match[pos] < 0.7 * len(seed):
                raise ValueError('ERROR: neither end of IN in F3, nor end of F3 in IN found')
            endB = search_start + pos + len(seed)
            seqBm = seqBm[:endB]
            nuBm = nuBm[:, :endB]
            S = S[:endB]
            aliB = aliB[:, :endB]
            aliBm = aliBm[:, :endB]
        else:
            raise ValueError('ERROR: end not found')
    else:
        end = search_start + pos + len(seed)

    # If their lengths differ, align
    if (end - start) != len(seqBm):
        seqmt = seqm[start: end]
        from seqanpy import align_global
        ali = align_global(seqBm.tostring(), seqmt.tostring(), band=50)
        # FIXME: admit only gaps in our seq (gaps got stripped!)
        if '-' in ali[1]:
            raise ValueError('ERROR: gap in subtype B alignment (not implemented yet)')
        alim2 = np.fromstring(ali[2], 'S1')
        ind = alim2 != '-'
        seqBm = seqBm[ind]
        S = S[ind]
        nuBm = nuBm[:, ind]

    return {'S': S, 'coord': (start, end),
            'seqB': seqBm, 'nuB': nuBm,
            'color': colors[protname]}



# Script
if __name__ == '__main__':

    # Parse input args
    parser = argparse.ArgumentParser(description='Get shared allele trajectories',
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)    
    parser.add_argument('--fragments', nargs='*',
                        help='Fragments to analyze (e.g. F1 F6)')
    parser.add_argument('--verbose', type=int, default=0,
                        help='Verbosity level [0-4]')
    parser.add_argument('--plot', nargs='?', default=None, const='2D',
                        help='Plot the allele frequency trajectories')

    args = parser.parse_args()
    fragments = args.fragments
    VERBOSE = args.verbose
    plot = args.plot

    if not fragments:
        fragments = ['F'+str(i) for i in xrange(1, 7)]
    if VERBOSE >= 2:
        print 'fragments', fragments

    plt.ioff()

    for fragment in fragments:
        if VERBOSE >= 1:
            print fragment

        # Get our own coordinates, stripping gaps
        ali = AlignIO.read(root_patient_folder+'all/aft_shared_ali_'+fragment+'.fasta', 'fasta')
        pnames = map(lambda x: x.name.split('_')[-1][1:], ali)
        patients = load_patients()
        patients = patients.loc[patients.index.isin(pnames)]
        alim = np.array(ali, 'S1')
        alim = alim[:, -((alim == '-').any(axis=0))]
        num = np.array([(alim == a).mean(axis=0) for a in alpha])
        seqm = alpha[num.argmax(axis=0)]

        # Low-coverage regions are bytecoded by -1
        from hivwholeseq.patients.filenames import root_patient_folder
        afts = np.load(root_patient_folder+'all/aft_shared_'+fragment+'.npy')
        n_patients = afts.shape[0]
        lseq = afts.shape[1]
        lalpha = afts.shape[2]

        # Look for parallel conservation
        threshold = 0.005
        n_poly = np.zeros((lseq, lalpha), int)  # Number of patients in which the allele is polymorphic at least once
        n_cov = np.zeros(lseq, int)	                # Number of patients with sufficient coverage
        for pos, aft_pos in enumerate(afts.swapaxes(0, 1).swapaxes(1, 2)): # Sort: pos, nuc, pats [, time] 
            if VERBOSE >= 3:
                print pos
            
            for j, aft_nuc in enumerate(aft_pos):
                n = 0
                nc = 0
                for aft_pat in aft_nuc:
                    # FIXME: deal better with missing data (low coverage)
                    times_cov = aft_pat >= -0.1
                    if times_cov.sum() < 3:
                        continue
                    nc += 1
                    aft_pat = aft_pat[times_cov]
                    if ((aft_pat > threshold) & (aft_pat < 1 - threshold)).any():
                        n += 1
                if j == 0:
                    n_cov[pos] = nc
                n_poly[pos, j] = n

        n_poly_max_raw = n_poly.max(axis=1)

        # Exclude sites covered by few patients only
        n_poly_max = n_poly_max_raw.copy()
        n_poly_max[n_cov < 5] = -1

        if VERBOSE >= 1:
            print 'Get subtype B multiple sequence alignment'
        protnames = {'F1': ['p17', 'p24'],
                     'F2': ['PR', 'RT'],
                     'F3': ['p15', 'IN'],
                     'F4': [], 'F5': [],
                     'F6': ['gp41']}
        data_ali = {}
        for protname in protnames[fragment]:
            if VERBOSE >= 1:
                print protname
            try:
                data_ali[protname] = get_subtype_B_obs(protname, seqm, VERBOSE=VERBOSE)
            except ValueError:
                continue
 
        if VERBOSE >= 1:
            print 'Calculate entropy for each patient'
        S = -np.ones((n_patients, lseq), float)
        S_time = np.zeros((n_patients, lseq), object)
        times_covs = np.zeros(n_patients, object)
        for k, aft_pat in enumerate(afts):
            if VERBOSE >= 3:
                print pat

            times_cov = aft_pat[0, 0] >= -0.1
            times_covs[k] = times_cov
            if times_cov.sum() < 2:
                S_time[k, :] = None
                continue
            
            for pos, aft_pos in enumerate(aft_pat):
                # FIXME: deal better with missing data (low coverage)
                Stmp = 0
                Stmp_time = np.zeros(times_cov.sum())
                for j, aft_nuc in enumerate(aft_pos):
                    aft_nuc = aft_nuc[times_cov]
                    Stmp -= ((aft_nuc + 1e-8) * np.log2(aft_nuc + 1e-8)).mean()
                    Stmp_time -= ((aft_nuc + 1e-8) * np.log2(aft_nuc + 1e-8))
                S[k, pos] = Stmp
                S_time[k, pos] = Stmp_time

        # Polarize by away/towards subtype B center


        # Correlation coefficients between these things
        from scipy.stats import pearsonr, spearmanr
        corrs = defaultdict(lambda: defaultdict(list))
        corrs_lowdiv = defaultdict(lambda: defaultdict(list))
        corrs_highdiv = defaultdict(lambda: defaultdict(list))
        Sthre = 0.1
        for protname, ddata in data_ali.iteritems():
            print protname
            (start, end) = ddata['coord']
            print 'Spearman r between n_poly_max and S_B:',
            print spearmanr(n_poly_max_raw[start: end], ddata['S'])

            print 'Spearman r between <S>_pats and S_B:',
            print spearmanr(S[:, start: end].mean(axis=0), ddata['S'])

            print 'Spearman r between <S>_time and S_B, for each patient:'
            for i in xrange(n_patients):
                print pnames[i], spearmanr(S[i, start: end], ddata['S'])

            print ''
            print 'Spearman r between <S>_time and S_B, for each patient and time:'
            for i in xrange(n_patients):
                patient = Patient(patients.iloc[i])
                if S_time[i, 0] is None:
                    continue
                for j in xrange(len(S_time[i, 0])):
                    S_time_pat = np.array(map(itemgetter(j), S_time[i]))[start: end]
                    S_subtypeB = ddata['S']
                    (r, pvalue) = spearmanr(S_time_pat, S_subtypeB)
                    corrs[protname][patient.name].append(r)

                    ind_lowd = S_subtypeB < Sthre
                    corrs_lowdiv[protname][patient.name].append(spearmanr(S_time_pat[ind_lowd], S_subtypeB[ind_lowd])[0])
                    corrs_highdiv[protname][patient.name].append(spearmanr(S_time_pat[-ind_lowd], S_subtypeB[-ind_lowd])[0])
                    print pnames[i], j, r, pvalue
                print ''


            print ''
            
        if plot:
            if VERBOSE:
                print 'Plot along fragment'
            fig, ax = plt.subplots(figsize=(16, 5))
            ax.plot(np.arange(len(n_poly_max)), 1.0 * n_poly_max_raw / n_patients, lw=1.5, c='b', label='# pats')
            ax.plot(np.arange(len(n_poly_max)), 5.0 * S.mean(axis=0), lw=1.5, c='k', label='5 * <S>_pats')
            ax.plot(np.arange(len(n_poly_max)), 1.0 * n_cov / n_patients, lw=1.5, c='gray')
            for protname, ddata in data_ali.iteritems():
                (start, end) = ddata['coord']
                ax.plot(np.arange(start, end), ddata['S'], lw=1.5, c=ddata['color'], label='subtype B '+protname)
            ax.set_xlabel('Position [bp]')
            ax.set_ylabel('frac patients polymorphic')
            ax.set_title(fragment)
            ax.set_xlim(-1, len(n_poly_max) + 1)
            ax.set_ylim(-0.2, 1.9)
            ax.legend(loc=1)

            plt.tight_layout()


            if VERBOSE:
                print 'Plot correlation during infection'
            fig, axs = plt.subplots(1, len(corrs.keys()), figsize=(1 + len(corrs.keys()) * 7, 8))
            for i, (protname, corrs_prot) in enumerate(corrs.iteritems()):
                ax = axs[i]
                for j, (pname, corr) in enumerate(corrs_prot.iteritems()):
                    color = cm.jet(1.0 * j / len(pnames))
                    patient = Patient(patients.loc[pname])
                    patient.discard_nonsequenced_samples
                    times = (patient.times - patient.transmission_date) / np.timedelta64(1, 'D')
                    times = times[times_covs[pnames.index(pname)]]
                    ax.plot(times, corr, lw=2, label=pname, c=color)

                ax.set_xlabel('Time from transmission [days]')
                if i == 0:
                    ax.set_ylabel('spearman r (S_sample, S_subtypeB)')
                ax.set_ylim(-0.02, 0.7)
                ax.set_title(protname)
                ax.legend(loc=4, fontsize=14)

            plt.tight_layout()


            if VERBOSE:
                print 'Plot correlation during infection stratified by conservation level'
            fig, axs = plt.subplots(1, len(corrs.keys()), figsize=(1 + len(corrs.keys()) * 7, 8))
            for i, protname in enumerate(corrs):
                ax = axs[i]
                for j, pname in enumerate(corrs_prot):
                    corr_low = corrs_lowdiv[protname][pname]
                    corr_high = corrs_highdiv[protname][pname]

                    color = cm.jet(1.0 * j / len(pnames))
                    patient = Patient(patients.loc[pname])
                    patient.discard_nonsequenced_samples
                    times = (patient.times - patient.transmission_date) / np.timedelta64(1, 'D')
                    times = times[times_covs[pnames.index(pname)]]
                    ax.plot(times, corr_low, lw=2, ls='-', label=pname+', S < '+str(Sthre), c=color)
                    ax.plot(times, corr_high, lw=2, ls='--', label=pname+', S > '+str(Sthre), c=color)

                ax.set_xlabel('Time from transmission [days]')
                if i == 0:
                    ax.set_ylabel('spearman r (S_sample, S_subtypeB)')
                ax.set_ylim(-0.02, 0.7)
                ax.set_title(protname)
                ax.legend(loc=4, fontsize=14)

            plt.tight_layout()

            
            if VERBOSE:
                print 'Plot entropy difference distribution with pat and time'
            for i in xrange(n_patients):
                # FIXME
                if i > 0:
                    break
                fig, ax = plt.subplots()

                S_pat = np.vstack(S_time[i])
                S_diff = {protname: S_pat[d['coord'][0]: d['coord'][1]] - d['S']
                          for protname, d in data_ali.iteritems()}

                S_diff = np.vstack(S_diff.itervalues())
                for j in xrange(S_diff.shape[1]):
                    ax.hist(S_diff[:, j], bins=10, label=pnames[i]+', '+str(j),
                            normed=True)

                ax.set_xlabel('Entropy difference [bits]')
                ax.set_ylabel('Density')



    if plot:
        plt.ion()
        plt.show()

